{"results":[{"dataType":"address","chain":"zilliqa","hash":"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy","checksumAddress":"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy","oldChecksumAddress":"0x685574a885c2913Ed47afF4c8ec2c068973fC8E3","extra":{"code":"scilla_version 0\n\nimport BoolUtils ListUtils IntUtils\nlibrary FungibleToken\n\nlet one_msg =\n  fun (msg : Message) =>\n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet two_msgs =\nfun (msg1 : Message) =>\nfun (msg2 : Message) =>\n  let msgs_tmp = one_msg msg2 in\n  Cons {Message} msg1 msgs_tmp\n\n(* Error events *)\ntype Error =\n  | CodeNotAuthorized\n  | CodeNotFound\n  | CodeInsufficientFunds\n\nlet make_error_event =\n  fun (result : Error) =>\n    let result_code =\n      match result with\n      | CodeNotAuthorized     => Int32 -1\n      | CodeNotFound          => Int32 -2\n      | CodeInsufficientFunds => Int32 -3\n      end\n    in\n    { _eventname : \"Error\"; code : result_code }\n\nlet min_int =\n  fun (a : Uint128) => fun (b : Uint128) =>\n  let min = builtin lt a b in\n  match min with\n  | True =>\n    a\n  | False =>\n    b\n  end\n\nlet f_eq =\n  fun (a : ByStr20) =>\n  fun (b : ByStr20) =>\n    builtin eq a b\n\nlet is_default_operator = @list_mem ByStr20\n\nlet get_balance =\n  fun (some_bal: Option Uint128) =>\n  match some_bal with\n  | Some bal => bal\n  | None => Uint128 0\n  end\n\ntype Unit =\n| Unit\n\nlet zero = Uint128 0\nlet one = Uint128 1\n\ncontract FungibleToken\n(contract_owner: ByStr20,\n  name : String,\n  symbol: String,\n  decimals: Uint32,\n  default_operators : List ByStr20,\n  init_supply : Uint128\n)\n\n(* Mutable fields *)\n\nfield total_supply : Uint128 = init_supply\n\nfield balances_map: Map ByStr20 Uint128 \n  = let emp_map = Emp ByStr20 Uint128 in\n  builtin put emp_map contract_owner init_supply\n\nfield operators_map: Map ByStr20 (Map ByStr20 Unit)\n  = Emp ByStr20 (Map ByStr20 Unit)\n\nfield revoked_default_operators : Map ByStr20 (Map ByStr20 Unit)\n  = Emp ByStr20 (Map ByStr20 Unit)\n\nfield allowances_map: Map ByStr20 (Map ByStr20 Uint128)\n  = Emp ByStr20 (Map ByStr20 Uint128)\n\n\nprocedure IssueErrorEvent(err : Error)\n  e = make_error_event err;\n  event e\nend\n\nprocedure AuthorizedMint(recipient: ByStr20, amount: Uint128)\n  get_bal <- balances_map[recipient];\n  balance = get_balance get_bal;\n  new_balance = builtin add amount balance;\n  balances_map[recipient] := new_balance;\n  current_total_supply <- total_supply;\n  new_total_supply = builtin add current_total_supply amount;\n  total_supply := new_total_supply;\n  e = {_eventname: \"Minted\"; minter: _sender; recipient: recipient; amount: amount};\n  event e\nend\n\nprocedure AuthorizedBurnIfSufficientBalance(from: ByStr20, amount: Uint128)\n  get_bal <- balances_map[from];\n  match get_bal with\n  | None =>\n    err = CodeInsufficientFunds;\n    IssueErrorEvent err\n  | Some bal =>\n    can_burn = uint128_le amount bal;\n    match can_burn with\n    | False =>\n      err = CodeInsufficientFunds;\n      IssueErrorEvent err\n    | True =>\n      (* Subtract amount from 'from' *)\n      new_balance = builtin sub bal amount;\n      balances_map[from] := new_balance;\n      current_total_supply <- total_supply;\n      new_total_supply = builtin sub current_total_supply amount;\n      total_supply := new_total_supply;\n      e = {_eventname: \"Burnt\"; burner: _sender; burn_account: from; amount: amount};\n      event e\n      end\n   end\nend\n\nprocedure AuthorizedMoveIfSufficientBalance(from: ByStr20, to: ByStr20, amount: Uint128)\n  get_from_bal <- balances_map[from];\n  match get_from_bal with\n  | Some bal =>\n    can_do = uint128_le amount bal;\n    match can_do with\n    | True =>\n      (* Subtract amount from \"from\" and add it to \"to\" address *)\n      new_from_bal = builtin sub bal amount;\n      balances_map[from] := new_from_bal;\n      (* Adds amount to \"to\" address *)\n      get_to_bal <- balances_map[to];\n      new_to_bal = match get_to_bal with\n      | Some bal => builtin add bal amount\n      | None => amount\n      end;\n      balances_map[to] := new_to_bal\n    | False =>\n      (* Balance not sufficient *)\n      err = CodeInsufficientFunds;\n      IssueErrorEvent err\n    end\n  | None =>\n    err = CodeNotFound;\n    IssueErrorEvent err\n  end\nend\n\ntransition IsOperatorFor(token_owner: ByStr20, operator: ByStr20)\n  is_operator_approved <- exists operators_map[token_owner][operator];\n  is_default_operator = is_default_operator f_eq operator default_operators;\n  is_revoked_operator <- exists revoked_default_operators[token_owner][operator];\n  is_default_operator_approved =\n    let is_not_revoked_operator = negb is_revoked_operator in\n    andb is_not_revoked_operator is_default_operator;\n  is_approved = orb is_operator_approved is_default_operator_approved;\n  msg_to_sender = { _tag : \"IsOperatorForCallBack\"; _recipient : _sender; _amount : Uint128 0;\n                    is_operator_for : is_approved};\n  msgs = one_msg msg_to_sender;\n  send msgs\nend\n\ntransition Mint(recipient: ByStr20, amount: Uint128)\n  is_owner = builtin eq _sender contract_owner;\n   match is_owner with\n    | False =>\n      err = CodeNotAuthorized;\n      IssueErrorEvent err\n    | True =>\n      AuthorizedMint recipient amount;\n      (* Prevent sending to a contract address that does not support transfers of token *)\n      msg_to_recipient = {_tag : \"RecipientAcceptMint\"; _recipient : recipient; _amount : zero;\n                          minter : _sender; recipient : recipient; amount : amount};\n      msg_to_sender = {_tag : \"MintSuccessCallBack\"; _recipient : _sender; _amount : zero;\n                          minter : _sender; recipient : recipient; amount : amount};\n      msgs = two_msgs msg_to_recipient msg_to_sender;\n      send msgs\n    end\nend\n\ntransition Burn(burn_account: ByStr20, amount: Uint128)\n  is_owner = builtin eq _sender contract_owner;\n    match is_owner with\n    | False =>\n      err = CodeNotAuthorized;\n      IssueErrorEvent err\n    | True =>\n      AuthorizedBurnIfSufficientBalance burn_account amount;\n      msg_to_sender = {_tag : \"BurnSuccessCallBack\"; _recipient : _sender; _amount : zero;\n                        burner : _sender; burn_account : burn_account; amount : amount};\n      msgs = one_msg msg_to_sender;\n      send msgs\n    end\nend\n\ntransition AuthorizeOperator(operator: ByStr20)\n  is_sender = builtin eq operator _sender;\n  match is_sender with\n  | True =>\n    (* _sender is authorizing self as operator, return error code *)\n    err = CodeNotAuthorized;\n    IssueErrorEvent err\n  | False =>\n    is_default_operator =  is_default_operator f_eq operator default_operators;\n    match is_default_operator with\n    | True =>\n      (* Re-authorize default_operator *)\n      delete revoked_default_operators[_sender][operator];\n      e = { _eventname : \"ReAuthorizedDefaultOperatorSuccess\"; authorizer : _sender; reauthorized_default_operator : operator};\n      event e\n    | False =>\n      (* Authorize new operator *)\n      authorize = Unit;\n      operators_map[_sender][operator] := authorize;\n      e = {_eventname : \"AuthorizeOperatorSuccess\"; authorizer : _sender; authorized_operator : operator};\n      event e\n    end\n  end\nend\n\ntransition RevokeOperator(operator: ByStr20)\n  is_default_operator = is_default_operator f_eq operator default_operators;\n  match is_default_operator with\n  | False =>\n    (* Not default_operator, check if operator *)\n    get_operator <- operators_map[_sender][operator];\n    match get_operator with\n    | None =>\n      (* Operator to be removed not found, error *)\n      err = CodeNotFound;\n      IssueErrorEvent err\n    | Some status =>\n      delete operators_map[_sender][operator];\n      e = {_eventname : \"RevokeOperatorSuccess\"; revoker : _sender; revoked_operator : operator};\n      event e\n    end\n  | True =>\n    (* Is default_operator, revoke default_operator authority instead *)\n    verdad = Unit;\n    revoked_default_operators[_sender][operator] := verdad;\n    e = {_eventname : \"RevokedDefaultOperatorSuccess\"; revoker : _sender; revoked_default_operator : operator};\n    event e\n  end\nend\n\ntransition IncreaseAllowance(spender: ByStr20, amount: Uint128)\n  (* Checks if the _sender and approved_spender is the same *)\n  is_owner = builtin eq _sender spender;\n  match is_owner with\n  | True =>\n    err = CodeNotAuthorized;\n    IssueErrorEvent err\n  | False =>\n    get_current_allowance <- allowances_map[_sender][spender];\n    current_allowance =\n      match get_current_allowance with\n      | Some allowance => allowance\n      | None => zero\n      end;\n    new_allowance = builtin add current_allowance amount;\n    allowances_map[_sender][spender] := new_allowance;\n    e = {_eventname : \"IncreasedAllowance\"; token_owner : _sender; spender: spender; new_allowance : new_allowance};\n    event e\n  end\nend\n\ntransition DecreaseAllowance(spender: ByStr20, amount: Uint128)\n  (* Checks if the _sender and approved_spender is the same *)\n  is_owner = builtin eq _sender spender;\n  match is_owner with\n  | True =>\n    err = CodeNotAuthorized;\n    IssueErrorEvent err\n  | False =>\n    get_current_allowance <- allowances_map[_sender][spender];\n    current_allowance =\n      match get_current_allowance with\n      | Some allowance => allowance\n      | None => zero\n      end;\n    new_allowance =\n      let amount_le_allowance = uint128_le amount current_allowance in\n      match amount_le_allowance with\n      | True => builtin sub current_allowance amount\n      | False => zero\n      end;\n    allowances_map[_sender][spender] := new_allowance;\n    e = {_eventname : \"DecreasedAllowance\"; token_owner : _sender; spender: spender; new_allowance : new_allowance};\n    event e\n  end\nend\n\ntransition Transfer(to: ByStr20, amount: Uint128)\n  AuthorizedMoveIfSufficientBalance _sender to amount;\n  e = {_eventname : \"Transfer\"; sender : _sender; recipient : to; amount : amount};\n  event e;\n  (* Prevent sending to a contract address that does not support transfers of token *)\n  msg_to_recipient = {_tag : \"RecipientAcceptTransfer\"; _recipient : to; _amount : zero;\n                      sender : _sender; recipient : to; amount : amount};\n  msg_to_sender = {_tag : \"TransferSuccessCallBack\"; _recipient : _sender; _amount : zero;\n                  sender : _sender; recipient : to; amount : amount};\n  msgs = two_msgs msg_to_recipient msg_to_sender;\n  send msgs\nend\n\ntransition OperatorSend(from: ByStr20, to: ByStr20, amount: Uint128)\n  is_operator_approved <- exists operators_map[from][_sender];\n  is_default_operator = is_default_operator f_eq _sender default_operators;\n  is_revoked_operator <- exists revoked_default_operators[from][_sender];\n  is_default_operator_approved = let is_not_revoked_operator =\n    negb is_revoked_operator in andb is_not_revoked_operator is_default_operator;\n  is_approved = orb is_operator_approved is_default_operator_approved;\n  match is_approved with\n    | False =>\n      err = CodeNotAuthorized;\n      IssueErrorEvent err\n    | True =>\n      AuthorizedMoveIfSufficientBalance from to amount;\n      e = {_eventname : \"OperatorSendSuccess\"; initiator : _sender; sender : from; recipient : to; amount : amount};\n      event e;\n      (* Prevent sending to a contract address that does not support transfers of token *)\n      msg_to_recipient = {_tag : \"RecipientAcceptOperatorSend\"; _recipient : to; _amount : zero;\n                          initiator : _sender; sender : from; recipient : to; amount : amount};\n      msg_to_sender = {_tag : \"OperatorSendSuccessCallBack\"; _recipient : _sender; _amount : zero;\n                      initiator : _sender; sender : from; recipient : to; amount : amount};\n      msgs = two_msgs msg_to_recipient msg_to_sender;\n      send msgs\n   end\nend\ntransition TransferFrom(from: ByStr20, to: ByStr20, amount: Uint128)\n  get_bal <- balances_map[from];\n  match get_bal with\n  | None =>\n    err = CodeNotFound;\n    IssueErrorEvent err\n  | Some bal =>\n    get_spender_allowed <- allowances_map[from][_sender];\n    match get_spender_allowed with\n    | None =>\n      err = CodeNotAuthorized;\n      IssueErrorEvent err\n    | Some allowed =>\n      min = min_int bal allowed;\n      can_do = uint128_le amount min;\n      match can_do with\n      | True =>\n        AuthorizedMoveIfSufficientBalance from to amount;\n        e = {_eventname : \"TransferFromSuccess\"; initiator : _sender; sender : from; recipient : to; amount : amount};\n        event e;\n        new_allowed = builtin sub allowed amount;\n        allowances_map[from][_sender] := new_allowed;\n        (* Prevent sending to a contract address that does not support transfers of token *)\n        msg_to_recipient = {_tag : \"RecipientAcceptTransferFrom\"; _recipient : to; _amount : zero;\n                            initiator : _sender; sender : from; recipient : to; amount : amount};\n        msg_to_sender = {_tag : \"TransferFromSuccessCallBack\"; _recipient : _sender; _amount : zero;\n                        initiator : _sender; sender : from; recipient : to; amount : amount};\n        msgs = two_msgs msg_to_recipient msg_to_sender;\n        send msgs\n      | False =>\n        err = CodeInsufficientFunds;\n        IssueErrorEvent err\n      end\n    end\n  end\nend\n","creator":{"address":"zil1zfwf3m3yumz9u73nwxatrlhryk0gwazm3tejum","tx":"2e65d0f4d3e97380936cd62a2703ee469a1e0ccc04f37c6e05a94dc3884cebcf"},"init":[{"type":"Uint32","value":"0","vname":"_scilla_version"},{"type":"ByStr20","value":"0x125C98Ee24E6C45e7A3371bAb1fEe3259e87745B","vname":"contract_owner"},{"type":"String","value":"HASI","vname":"name"},{"type":"String","value":"HASI","vname":"symbol"},{"type":"Uint32","value":"2","vname":"decimals"},{"type":"List ByStr20","value":["0x501A70ffEAA3F31C1caccE3479e74713546BAA44","0xBFe2445408C51CD8Ee6727541195b02c891109ee","0x428A2aA43456FE7fd2De66E48C1fBf372eC10eAE"],"vname":"default_operators"},{"type":"Uint128","value":"100000000","vname":"init_supply"},{"type":"BNum","value":"1182347","vname":"_creation_block"},{"type":"ByStr20","value":"0x685574a885c2913ed47aff4c8ec2c068973fc8e3","vname":"_this_address"}],"state":{"_balance":"0","allowances_map":{},"balances_map":{"0x09e5a1d215a9ec8ebf31828e5264d9d1ca879b11":"5050000","0x125c98ee24e6c45e7a3371bab1fee3259e87745b":"84950000","0xaa2ba71856725cd9853b210eaa5e99f29a28c300":"5000000","0xc3d900b37f0b72667b55a82acad457ec54c6b2fd":"5000000"},"operators_map":{},"revoked_default_operators":{},"total_supply":"100000000"},"type":"contract","aextxuidCount":18,"nonce":0},"balance":"0","txCount":18,"internalsCount":0,"txs":{"docs":[{"hash":"0x2e65d0f4d3e97380936cd62a2703ee469a1e0ccc04f37c6e05a94dc3884cebcf","timestamp":1582990453657,"status":"mined","fee":"15737000000000","labels":{},"addressTypes":{"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy":"contract"},"direction":"in","from":"zil1zfwf3m3yumz9u73nwxatrlhryk0gwazm3tejum","to":"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy","value":"0","type":"contract","extra":{"msgId":"contractCreation"}},{"hash":"0xca6bcfd86f6fd429333c742e14d4c5c95b40b760383890964794fdb44d652f0d","timestamp":1582993015987,"status":"mined","fee":"5640000000000","labels":{},"addressTypes":{"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy":"contract"},"direction":"in","from":"zil1zfwf3m3yumz9u73nwxatrlhryk0gwazm3tejum","to":"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy","value":"0","type":"contract","extra":{}},{"hash":"0xc2fef9b94636b8a4f1be261f4d210b6a23cb5ae0806acb574041a0eb97006197","timestamp":1582995763419,"status":"mined","fee":"5640000000000","labels":{},"addressTypes":{"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy":"contract"},"direction":"in","from":"zil1zfwf3m3yumz9u73nwxatrlhryk0gwazm3tejum","to":"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy","value":"0","type":"contract","extra":{}},{"hash":"0x55d5b5754fd108135056681de34d1c85fc9bbdcd08fa5eba6094025ad0699b4d","timestamp":1582996165581,"status":"mined","fee":"1128000000000","labels":{},"addressTypes":{"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy":"contract"},"direction":"in","from":"zil1zfwf3m3yumz9u73nwxatrlhryk0gwazm3tejum","to":"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy","value":"0","type":"contract","extra":{}},{"hash":"0x0f1c1da4e6f5cb0dc594523df4efa78802c5dfad20b0c1c1feb03af34c640eec","timestamp":1582997221639,"status":"mined","fee":"1128000000000","labels":{},"addressTypes":{"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy":"contract"},"direction":"in","from":"zil1zfwf3m3yumz9u73nwxatrlhryk0gwazm3tejum","to":"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy","value":"0","type":"contract","extra":{}},{"hash":"0x9922915dab5fd7c153f48928130b421470409d7d889d62e93b386ea3ce8572f0","timestamp":1582997531047,"status":"mined","fee":"1128000000000","labels":{},"addressTypes":{"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy":"contract"},"direction":"in","from":"zil1zfwf3m3yumz9u73nwxatrlhryk0gwazm3tejum","to":"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy","value":"0","type":"contract","extra":{}},{"hash":"0x5aca41f678c84f08f204ef5b5d99856527137dbd40d97de33ae31f5edaeb9fa1","timestamp":1582997685405,"status":"mined","fee":"1844000000000","labels":{},"addressTypes":{"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy":"contract"},"direction":"in","from":"zil1zfwf3m3yumz9u73nwxatrlhryk0gwazm3tejum","to":"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy","value":"0","type":"contract","extra":{}},{"hash":"0x2b01200488edb05ad900158e028335f4a90ed1bc402e951b5d53fb6d22f73eb2","timestamp":1582997963812,"status":"mined","fee":"1822000000000","labels":{},"addressTypes":{"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy":"contract"},"direction":"in","from":"zil1zfwf3m3yumz9u73nwxatrlhryk0gwazm3tejum","to":"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy","value":"0","type":"contract","extra":{}},{"hash":"0xd99a9e9463cc58b9179311971dc1ffb7407edba83d4345036ce5f28f01548407","timestamp":1582998304183,"status":"mined","fee":"1128000000000","labels":{},"addressTypes":{"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy":"contract"},"direction":"in","from":"zil1zfwf3m3yumz9u73nwxatrlhryk0gwazm3tejum","to":"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy","value":"0","type":"contract","extra":{}},{"hash":"0x96a11b80b5d4ef8428d68face609bd7dcd5e7ab87d7d8eb59381bfe39e8e7ca2","timestamp":1582998485314,"status":"mined","fee":"1128000000000","labels":{},"addressTypes":{"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy":"contract"},"direction":"in","from":"zil1zfwf3m3yumz9u73nwxatrlhryk0gwazm3tejum","to":"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy","value":"0","type":"contract","extra":{}},{"hash":"0x2b5e69ba9346a04466a8371e58ea699413ae1f101da2700b3b9c0883b1723d17","timestamp":1582998762916,"status":"mined","fee":"1128000000000","labels":{},"addressTypes":{"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy":"contract"},"direction":"in","from":"zil1zfwf3m3yumz9u73nwxatrlhryk0gwazm3tejum","to":"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy","value":"0","type":"contract","extra":{}},{"hash":"0x8682b3f517026239f507f0b8a90dac883bfa7de14fc79faf37292c0e2e676e70","timestamp":1582998948100,"status":"mined","fee":"1822000000000","labels":{},"addressTypes":{"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy":"contract"},"direction":"in","from":"zil1zfwf3m3yumz9u73nwxatrlhryk0gwazm3tejum","to":"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy","value":"0","type":"contract","extra":{}},{"hash":"0x1cd9cbef982e6386a14940074b2a4fb3c0b010b1de46e5fac43cab0e398cf9b0","timestamp":1582999814070,"status":"mined","fee":"1128000000000","labels":{},"addressTypes":{"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy":"contract"},"direction":"in","from":"zil1zfwf3m3yumz9u73nwxatrlhryk0gwazm3tejum","to":"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy","value":"0","type":"contract","extra":{}},{"hash":"0x210c7020f8051f1271ac49f6fef9f6efd07b1452487f5047a8d724ba0599825c","timestamp":1582999907088,"status":"mined","fee":"1128000000000","labels":{},"addressTypes":{"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy":"contract"},"direction":"in","from":"zil1zfwf3m3yumz9u73nwxatrlhryk0gwazm3tejum","to":"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy","value":"0","type":"contract","extra":{}},{"hash":"0x43c473ddaa4d3eee3e3953a1357fd0c8ac657ff98e7623df67ddd174cabab566","timestamp":1582999999720,"status":"mined","fee":"1822000000000","labels":{},"addressTypes":{"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy":"contract"},"direction":"in","from":"zil1zfwf3m3yumz9u73nwxatrlhryk0gwazm3tejum","to":"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy","value":"0","type":"contract","extra":{}},{"hash":"0xc2973b8605ac835913e8da5b8cd3ab62db363a1f57acfd421c6b51ad088a636f","timestamp":1583050013563,"status":"mined","fee":"1842000000000","labels":{},"addressTypes":{"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy":"contract"},"direction":"in","from":"zil1zfwf3m3yumz9u73nwxatrlhryk0gwazm3tejum","to":"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy","value":"0","type":"contract","extra":{}},{"hash":"0x28f890c7a9ad958bc5b4fdf7b10fb78621fd1da4b76b54650bade7cd8b140498","timestamp":1583051438367,"status":"mined","fee":"1128000000000","labels":{},"addressTypes":{"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy":"contract"},"direction":"in","from":"zil1zfwf3m3yumz9u73nwxatrlhryk0gwazm3tejum","to":"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy","value":"0","type":"contract","extra":{}},{"hash":"0x9a2e1e0c42db065cd75ed017ca875627fb81b3477b0e0eeb099e95991e84adf3","timestamp":1583051655129,"status":"mined","fee":"1128000000000","labels":{},"addressTypes":{"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy":"contract"},"direction":"in","from":"zil1zfwf3m3yumz9u73nwxatrlhryk0gwazm3tejum","to":"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy","value":"0","type":"contract","extra":{}}],"page":1,"limit":25,"pages":1,"total":18,"type":"all","tokens":{}}},{"dataType":"address","chain":"thundercore","hash":"0xzil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy","checksumAddress":"0xzIl1dp2hF2y9C2Gna4r6LAxgAskqDZtNlj8rlQtLUy","balance":0,"txCount":0,"txs":{"docs":[],"page":1,"limit":25,"pages":1,"total":0,"type":"all","tokens":{}}}],"nameData":{"error":true},"value":"zil1dp2hf2y9c2gna4r6laxgaskqdztnlj8rlqtluy"}